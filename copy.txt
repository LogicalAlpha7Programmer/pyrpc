A = TypeVar("A")
B = TypeVar("B")
C = TypeVar("C")
D = TypeVar("D")
E = TypeVar("E")
F = TypeVar("F")
G = TypeVar("G")
H = TypeVar("H")
I = TypeVar("I")
J = TypeVar("J")
K = TypeVar("K")
L = TypeVar("L")
M = TypeVar("M")
N = TypeVar("N")
O = TypeVar("O")
P = TypeVar("P")
Q = TypeVar("Q")
R = TypeVar("R")
S = TypeVar("S")
T = TypeVar("T")
U = TypeVar("U")


class AuthRoutes(TypedDict):
    sign_in: Callable[[P], str]
    sign_up: Callable[[M], str]


class ThisRoutes(TypedDict):
    auth: AuthRoutes
    h: Callable[[P], str]


routes: ThisRoutes = {
    "auth": {
        "sign_in": signIn,
        "sign_up": auth.input(schemaW(M)).execute(lambda inputs, ctx: "23"),
    },
    "h": signIn,
}


@dataclass
class Routes:
    @dataclass
    class Auth:
        sign_in: Callable[[P], str] = signIn
        sign_up: Callable[[M], str] = auth.input(schemaW(M)).execute(lambda inputs, ctx: "23")

    h: Callable[[P], str] = signIn


func_routes = lambda: None
func_routes.sign_in = signIn
func_routes.sign_up = auth.input(schemaW(M)).execute(lambda inputs, ctx: "23")
func_routes.h = signIn


class class_routes:
    pass


class_routes.sign_in = signIn
x = Routes.Auth.sign_up(M(m=2))
y = routes["auth"]["sign_in"](P(i=2))
z = func_routes.sign_up(M(m=2))
l = class_routes.sign_in(P(i=2))












# import functools, inspect
# from typing import Any, BinaryIO, Callable, Coroutine, Sequence, TypeVar
# from fastapi import FastAPI, APIRouter
#
# class PyRPCProcedure:
#     def __init__(self, route: "Pyrpc", dependencies: tuple | list = ()) -> None:
#         self.__route = route
#         self.__router = self.__route.router_or_api
#         self.dependencies = list(dependencies)
#         self.opts = {}
#
#     def query(self):
#         def wrapper(func: Callable):
#
#             async def wrapped[A, B](*args: A, **kwargs: B):
#                 return await func(*args, **kwargs, **self.opts)
#
#             self.__router.add_api_route(path=func.__name__ + "/", endpoint=wrapped)
#             return wrapped
#
#         return wrapper
#
#     def mutate(self):
#
#         def wrapper(func: Callable):
#             @self.__router.post(
#                 path=func.__name__ + "/",
#                 dependencies=self.dependencies,
#             )
#             async def wrapped(*args, **kwargs):
#                 return await func(*args, **kwargs, **self.opts)
#
#             return wrapped
#
#         return wrapper
#
#     def depends(self, *args, **kwargs):
#         kwargs.update(args)
#         self.dependencies += list(kwargs.values())
#         self.opts = kwargs
#         return self
#
#     def procedure(self):
#         return PyRPCProcedure(route=self.__route, dependencies=self.dependencies)
#
#
# class Pyrpc:
#     def __init__(self, router_or_api: APIRouter | FastAPI):
#         self.router_or_api = router_or_api
#
#     def route(self, router: APIRouter):
#         self.router_or_api.include_router(router)
#         return Pyrpc(router_or_api=router)
#
#     def procedure(self):
#         return PyRPCProcedure(route=self)
#
#
# app = FastAPI()
#
# p = Pyrpc(router_or_api=app)
#
#
# @p.procedure().mutate()
# async def hello(message: str, **opts):
#     return {"message": message, "opts": opts}
